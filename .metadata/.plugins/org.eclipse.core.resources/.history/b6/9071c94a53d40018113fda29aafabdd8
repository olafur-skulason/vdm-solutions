\begin{vdmpp}[breaklines=true]
class Plant

instance variables

alarms   : set of Alarm;
schedule : map Period to set of Expert;
inv PlantInv(alarms,schedule);

functions
(*@
\label{PlantInv:11}
@*)

PlantInv: set of Alarm * map Period to set of Expert -> 
          bool
PlantInv(as,sch) ==
  (forall p in set dom sch & sch(p) <> {}) and
  (forall a in set as &
     forall p in set dom sch &
       exists expert in set sch(p) &
         a.GetReqQuali() in set expert.GetQuali());

types

public Period = token;

operations
(*@
\label{ExpertToPage:26}
@*)

pure public ExpertToPage: Alarm * Period ==> Expert
ExpertToPage(a, p) ==
  let expert in set schedule(p) be st
      a.GetReqQuali() in set expert.GetQuali()
  in
    return expert
pre a in set alarms and
    p in set dom schedule
post let expert = RESULT
     in
       expert in set schedule(p) and
       a.GetReqQuali() in set expert.GetQuali();
(*@
\label{NumberOfExperts:39}
@*)

pure public NumberOfExperts: Period ==> nat
NumberOfExperts(p) ==
  (*@\vdmnotcovered{return}@*) card (*@\vdmnotcovered{schedule}@*)((*@\vdmnotcovered{p}@*))
pre p in set (*@\vdmnotcovered{dom}@*) (*@\vdmnotcovered{schedule}@*);
(*@
\label{ExpertIsOnDuty:44}
@*)

pure public ExpertIsOnDuty: Expert ==> set of Period
ExpertIsOnDuty(ex) ==
  return {p | p in set dom schedule & 
              ex in set schedule(p)};
(*@
\label{Plant:49}
@*)

public Plant: set of Alarm * 
              map Period to set of Expert ==> Plant
Plant(als,sch) ==
( alarms := als;
  schedule := sch
)
pre PlantInv(als,sch);

(*@
\label{AddExpertToSchedule:58}
@*)
public AddExpertToSchedule: Period * Expert ==> ()
AddExpertToSchedule(p,ex) ==
  (*@\vdmnotcovered{schedule}@*)((*@\vdmnotcovered{p}@*)) := (*@\vdmnotcovered{if}@*) p (*@\vdmnotcovered{in}@*) set dom (*@\vdmnotcovered{schedule}@*)
                 then (*@\vdmnotcovered{schedule}@*)(p) (*@\vdmnotcovered{union}@*) (*@\vdmnotcovered{\{}@*)(*@\vdmnotcovered{ex}@*)}
                 else {(*@\vdmnotcovered{ex}@*)};
  
-- this one is erronerous but combinatorial testing should find that                 
(*@
\label{RemoveExpertFromSchedule:65}
@*)
public RemoveExpertFromSchedule: Period * Expert ==> ()
RemoveExpertFromSchedule(p,ex) == 
  let exs = (*@\vdmnotcovered{schedule}@*)((*@\vdmnotcovered{p}@*))
  in
    schedule := (*@\vdmnotcovered{if}@*) (*@\vdmnotcovered{card}@*) (*@\vdmnotcovered{exs}@*) (*@\vdmnotcovered{=}@*) (*@\vdmnotcovered{1}@*)
                then {(*@\vdmnotcovered{p}@*)} (*@\vdmnotcovered{<-:}@*) (*@\vdmnotcovered{schedule}@*)
                else schedule ++ {(*@\vdmnotcovered{p}@*) (*@\vdmnotcovered{|->}@*) exs (*@\vdmnotcovered{\textbackslash }@*) (*@\vdmnotcovered{\{}@*)(*@\vdmnotcovered{ex}@*)}}
pre p (*@\vdmnotcovered{in}@*) set (*@\vdmnotcovered{dom}@*) (*@\vdmnotcovered{schedule}@*);
                
end Plant
\end{vdmpp}
\bigskip
\begin{longtable}{|l|r|r|r|}
\hline
Function or operation & Line & Coverage & Calls \\
\hline
\hline
\hyperref[AddExpertToSchedule:58]{AddExpertToSchedule} & 58&0.0\% & 0 \\
\hline
\hyperref[ExpertIsOnDuty:44]{ExpertIsOnDuty} & 44&100.0\% & 1 \\
\hline
\hyperref[ExpertToPage:26]{ExpertToPage} & 26&100.0\% & 2 \\
\hline
\hyperref[NumberOfExperts:39]{NumberOfExperts} & 39&0.0\% & 0 \\
\hline
\hyperref[Plant:49]{Plant} & 49&100.0\% & 1 \\
\hline
\hyperref[PlantInv:11]{PlantInv} & 11&100.0\% & 2 \\
\hline
\hyperref[RemoveExpertFromSchedule:65]{RemoveExpertFromSchedule} & 65&0.0\% & 0 \\
\hline
\hline
plant.vdmpp & & 60.1\% & 6 \\
\hline
\end{longtable}

